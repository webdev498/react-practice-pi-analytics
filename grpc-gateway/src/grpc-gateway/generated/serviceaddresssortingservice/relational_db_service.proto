//
// Copyright (c) 2016 Practice Insight Pty Ltd. All rights reserved.
//

syntax = "proto3";
package pi_relational_db;
option java_package = "pi.ip.data.relational.generated";
option java_multiple_files = true;

// This package is available via service definition PiKubeServiceImpl#IP_DATA_RELATIONAL_SERVICE_HOST
// If running outside of cluster but need production services, e.g. google dataflow, be sure to set
// CONF_PI_PROJECT_ID to the project id that is running the dataflow

import "patent_common.proto";

service PatUpdateService {

    rpc PersistNewPublication (CoreBiblio) returns (AckResponse) {
        // if filing date older than 7 years skipped
        // only where first publication date is within 2 years are records saved by this method
        // if new record saved, it fetches the applicant information and saves at time of creation
    }

    rpc PersistCiteMember (CoreBiblio) returns (AckResponse) {
        // if exists in PatentApp, no action needed
        // if older than 20 years, no action needed
        // no applicants required if persisted to archive
        // for pac citation references, request archive store/fetch to determine law firm
        // a record is created in PatentArchive if not existing previously
    }

    rpc PersistPriorityPublication (PersistPriorityRequest) returns (AckResponse) {
        // inserts into PctApp / RegApp table as required
        // if new record saved, it fetches the applicant information and saves at time of creation
    }

    // informs DB that UniPatNum is applicant filed by updating the 4 pat tables
    // see IPFLOW-700
    rpc MarkApplicantFiled(UniMsg) returns (AckResponse) {
    }

    // requests relational db service to set the classification info for use in FA service
    rpc SetMissingClassifications (UniFamilyMsg) returns (AckResponse) {
        option deprecated = true; // DEPRECATED we should push data to MySQL but not ask it to gather it

        // 1. check if classification info is already set in DB for uniPatNum in 3 tables, and if yes, return

        // next step:
        // 2. IF another family member in PatentApp has classification set, use that info and jump to step (4)

        // 3. Get list of family members from patent_number service, and iterate over ipcr of each until
        // a valid/known classification is found

        // NB: No need to store to join table re ipcr - just interested in the high level classifications

        // 4. if/when valid/known classification found, find all in 3 tables (PatentApp/RegApp/PctApp) WHERE no
        // classification info is recorded for given familyId, then set for all those records and return

        // 5. if classification cannot be determined or any exception, throw it back to the caller
    }

    // requests relational db service to updated applicants to `latest` for given uniPatNum
    rpc UpdateApplicantFamily (UpdateApplicantFamilyRequest) returns (AckResponse) {
        option deprecated = true; // DEPRECATED we should push data to MySQL but not ask it to gather it
        // 1. Search for apps in 3 tables (skip PatentArchive) with
        //     -- given familyId
        //     -- AND where (applicant_updated=0 or < `applicant_updated`)  [update_date may be zero, which is OK]
        // 2. If no uniPatNum found meeting criteria, return
        // 3. Get applicants based on familyId from names service and prepare `applicantBasicIdSet`
        // 4. If applicantBasicIdSet is not empty (forach app identified from the 3 tables):
        // 5. Set applicant join table and any applicant (first in set)`displayApplicant` (deprecated)
        // 6. Set applicant_updated to todayUtc (yyyyMMdd)
    }

    // Get the id for a name + country pair.  If the name + country pair do not exist, persist it to DB and return id.
    rpc UpsertApplicantBasic (UpsertApplicantBasicRequest) returns (UpsertApplicantBasicResponse) {
        option deprecated = true; // DEPRECATED not using id
    }

    // IPFLOW-51 remove this method after IPFLOW-51 resolved
    rpc SetIpCClassificationDdXml (SetMetaDdXmlRequest) returns (SetMetaDdXmlResponse) {
        option deprecated = true; // DEPRECATED in favour of PersistPubUpdateXml
    }
}

service LawFirmDbService {
    // get information about a law firm by id;
    // the service returns the information stored in the law_firm SQL table
    rpc GetLawFirmById (GetLawFirmByIdRequest) returns (GetLawFirmByIdResponse) {
    }

    rpc GetLawFirmsByIds (GetLawFirmsByIdsRequest) returns (GetLawFirmsByIdsResponse) {
    }

    rpc CreateLawFirm (CreateLawFirmRequest) returns (CreateLawFirmResponse) {
    }

    // provide batches of sync records to be consumed by flow
    rpc GetSyncUniPatLawFirm (GetSyncUniPatLawFirmRequest) returns (GetSyncUniPatLawFirmResponse) {
        // deprecated - add the sync_law_firm logic into SyncService
    }

    // remove successfully synced records
    rpc DeleteSyncUniPatLawFirm (DeleteSyncUniPatLawFirmRequest) returns (AckResponse) {
        // deprecated - add the sync_law_firm logic into SyncService
    }

    //search given uniPat number against patent_app and patent_archive
    //find the first lawFirm and return
    rpc GetLawFirmByUniPat (UniMsg) returns (LawFirm) {
    }

    //search given uniPat number against patent_app and patent_archive
    //find the first lawFirm and return
    rpc GetLawFirmsByUniPats (LawFirmsByUniPatsRequest) returns (LawFirmsByUniPatsResponse) {
    }
}

service ServiceAddressService {
    // Data stored in the service_address Cloud SQL table

    rpc GetServiceAddressById (GetServiceAddressByIdRequest) returns (ServiceAddress) {
        // Returns Status.NOT_FOUND error code if the service address can't be found
    }

    rpc GetServiceAddressesForLawFirm (GetServiceAddressesForLawFirmRequest)
            returns (GetServiceAddressesForLawFirmResponse) {
    }

    rpc AssignServiceAddressToLawFirm (AssignServiceAddressToLawFirmRequest) returns (AckResponse) {
    }

    rpc UnassignServiceAddressFromLawFirm (UnassignServiceAddressFromLawFirmRequest) returns (AckResponse) {
    }

    rpc SetServiceAddressAsNonLawFirm (SetServiceAddressAsNonLawFirmRequest) returns (AckResponse) {
    }
}

service ConfigurationService {

    // Fetch config value for a given key
    rpc GetConfigValue (GetConfigValueRequest) returns (GetConfigValueResponse) {
    }

    // Set config value for a given key
    rpc SetConfigValue (SetConfigValueRequest) returns (SetConfigValueResponse) {
    }
}

service SyncService {

    // Stream sync records to be consumed by flow
    rpc GetSyncLawFirms (SyncRequest) returns (stream SyncLawFirm) {
        // If SyncRequest.limit_result_count is 0, streams all the SyncLawFirm records out
    }

    rpc GetSyncPatApps (SyncRequest) returns (stream SyncApp) {
    }

    rpc GetSyncPatArchives (SyncRequest) returns (stream SyncApp) {
    }

    // Provide batches of sync records to be consumed by flow
    rpc GetSyncLawFirmBatch (SyncRequest) returns (GetSyncLawFirmResponse) {
        // Deprecated
    }

    // Remove successfully synced records
    rpc DeleteSyncLawFirm (DeleteSyncLawFirmRequest) returns (AckResponse) {
    }

    rpc DeleteSyncPatApp (DeleteSyncAppRequest) returns (AckResponse) {
    }

    rpc DeleteSyncPatArchive (DeleteSyncAppRequest) returns (AckResponse) {
    }

    rpc GetPendingSync(PendingSyncRequest) returns (stream SqlSyncRow) {

    }

    // when deleting pending sync, only sync_id is mandatory
    rpc DeletePendingSync(SqlSyncRow) returns (AckResponse) {
    }

    rpc SetGeoForServiceAddr(stream GeoForServiceAddrRequest) returns (AckResponse) {
    }
}

message GeoForServiceAddrRequest {
    enum GeoResultType {
        GeoAPIRefusesInput = 0;
        ValidGeoResult = 1;
    }

    uint64 id = 1;
    GeoResultType geo_result_type = 2;
    double lat = 3;
    double long = 4;
}

message PendingSyncRequest {
    int32 limit = 1;
}

message SqlSyncRow {
    string sync_id = 1;
    SqlSyncTable sync_table = 2;
    string data_blob = 3;
}

enum SqlSyncTable {
    INVALID = 0;
    SYNC_APPB = 1;
    SYNC_APPB_APP = 2;
    SYNC_APPB_PCT = 3;
    SYNC_APPB_REG = 4;
    SYNC_LAWF = 5;
    SYNC_PAT_ACH = 6;
    SYNC_PAT_APP = 7;
    SYNC_PCT_APP = 8;
    SYNC_REG_APP = 9;
    SYNC_SERVADDR = 10;
    SYNC_PAT_NEW_ALL = 11;
    SYNC_PAT_NEW_FA = 12;
}

message LawFirmsByUniPatsRequest {
    repeated string uni_pat_nums = 1;
}

message LawFirmsByUniPatsResponse {
    repeated UniPatLawFirm uni_pat_law_firms = 1;
}

message GetServiceAddressByIdRequest {
    int64 service_address_id = 1;
}

message GetServiceAddressesForLawFirmRequest {
    int64 law_firm_id = 1;
}

message GetServiceAddressesForLawFirmResponse {
    repeated ServiceAddress service_addresses = 1;
}

message AssignServiceAddressToLawFirmRequest {
    int64 service_address_id = 1;
    int64 law_firm_id = 2;
}

message UnassignServiceAddressFromLawFirmRequest {
    int64 service_address_id = 1;
    int64 law_firm_id = 2;
}

message SetServiceAddressAsNonLawFirmRequest {
    int64 service_address_id = 1;
}

message SyncRequest {
    // Positive integer specifying the maximum number of results to return (sql LIMIT `limit_result_count`)
    int32 limit_result_count = 1;
}

message GetSyncLawFirmResponse {
    // Empty list indicates that no results are available
    repeated SyncLawFirm result_list = 1;
}

message GetSyncAppResponse {
    // Empty list indicates that no results are available
    repeated SyncApp result_list = 1;
}

message DeleteSyncLawFirmRequest {
    // SYNC_LAWF.id
    int64 sync_id = 1;
}

message DeleteSyncAppRequest {
    // zsync_hb_uni_pat_lf.id
    int64 sync_id = 1;
}

message DeleteSyncUniPatLawFirmRequest {
    // zsync_hb_uni_pat_lf.id
    int64 sync_id = 1;
}

message SyncUniPatLawFirm {
    // zsync_hb_uni_pat_lf.id
    int64 sync_id = 1;

    // zsync_hb_uni_pat_lf.uni_pat
    string uni_pat = 2;

    // zero represents null
    int64 law_firm_id_old = 3;

    // zero represents null
    int64 law_firm_id_new = 4;

    // zero represents null
    int64 family_id = 5;

    // timsetamp converted to epoch long
    int64 event_ts = 6;
}

message GetSyncUniPatLawFirmRequest {
    // positive integer specifying the maximum number of results to return (sql LIMIT `limit_result_count`)
    int32 limit_result_count = 1;
}

message GetSyncUniPatLawFirmResponse {
    // empty list indicates that no results are available
    repeated SyncUniPatLawFirm sync_uni_pat_law_firm = 1;
}

message CoreBiblio {
    string uni_pat_num = 1;
    string app_no_ed = 2;
    int64 fam_id = 3;
    int32 earliest_pub_date = 4;
}

message PersistPriorityRequest {
    CoreBiblio core_biblio = 1;
    string priority_xml = 2;
}

message PersistPatentBaseRequest {
    string uni_pat_num = 1;
    string priority_xml = 2;
    int64 fam_id = 3;
    // earliest known pub date
    int32 pub_date = 4;
    string app_no_ed = 5;
}

message PersistPatentPubOnlyRequest {
    string uni_pat_num = 1;
    int64 fam_id = 2;
    // earliest known pub date
    int32 pub_date = 3;
    string app_no_ed = 4;
}

message SetClassificationMsg {
    UniFamilyMsg uni_family_msg = 1;
    string exch_doc_xml_wrapper = 2;
    string ipcr_xml = 3;
}

message UpdateApplicantFamilyRequest {
    int64 family_id = 1;
    int32 update_date_utc = 2; // yyyyMMdd
}

message PersistPatentRequest {
    string uni_pat_num = 1;
    string exch_doc_xml_wrapper = 2;
    string priority_xml = 3;
    string ipcr_xml = 4;
}

message GetLawFirmsByIdsRequest {
    repeated int64 law_firm_ids = 1;
}

message GetLawFirmsByIdsResponse {
    repeated LawFirm law_firms = 1;
}

message GetLawFirmByIdRequest {
    int64 law_firm_id = 1; // required
}

message GetLawFirmByIdResponse {
    enum GetLawFirmByIdResult {
        LAW_FIRM_LOOKUP_OK = 0;
        LAW_FIRM_NOT_FOUND = 1;
    }

    GetLawFirmByIdResult result = 1;
    LawFirm law_firm = 2;  // Will not be set in case of LAW_FIRM_NOT_FOUND
}

message CreateLawFirmRequest {
    LawFirm law_firm = 1;
    string created_by = 2;  // Sets last_user_edit to the staff member who created this record
}

message CreateLawFirmResponse {
    int64 law_firm_id = 1;
}


message GetConfigValueRequest {
    string config_key = 1;
}

message GetConfigValueResponse {
    string config_key = 1;
    // returns empty string if config key not found
    string config_value = 2;
}

message SetConfigValueRequest {
    string config_key = 1;
    string config_value = 2;
}

message SetConfigValueResponse {
}

message DocDbXml {
    // snappy compressed binary of docdb xml string
    bytes doc_db_xml_snappy = 1;
}

message SetMetaDdXmlRequest {
    string doc_db_xml = 1;
}

message SetMetaDdXmlResponse {
    // no response fields, throws exception via onError or otherwise completed
}

message PersistDdXmlRequest {
    enum JpaPersistType {
        ANALYTICS = 0;
    }
    JpaPersistType jpa_persist_type = 1 [deprecated = true];
    string doc_db_xml = 2;
}

message PersistDdXmlResponse {
    enum PersistDdXmlResult {
        OK = 0;
    }
    PersistDdXmlResult persist_result = 1;
}

message UpsertApplicantBasicRequest {
    string name_dd = 1; // required name in DOCDB format
    string country = 2; // required
}

message UpsertApplicantBasicResponse {
    // name and country in return response will match request.  The id will be added in response.
    AppBasicMsg app_basic = 1;
}

message AppBasicMsg {
    int64 id = 1;
    string name = 2;
    string country = 3;
}

message PatentPub {
    // PatentApp#appNumber or PatentArchive#appNumber
    string app_no_ed = 1;
    // PatentApp#lawFirmDetermined or PatentArchive#lawFirmDetermined
    bool law_firm_determined = 2;

    // For the optional items below:
    // PatentApp#serviceAddress#lawFirmEntity or PatentApp#serviceAddress#lawFirmEntity
    int64 law_firm_id = 3;
    string law_firm_name = 4;
    string law_firm_state = 5;
    string law_firm_country = 6;

    repeated AppBasicMsg app_basic_list = 7;
}

message PersistCitationForLawFirmRequest {
    string uni_pat_num = 1;
    int64 family_id = 2;
}

message PersistCitationForLawFirmResponse {
    enum PersistLawFirmResult {
        OKAY = 0;
    }
    PersistLawFirmResult persist_result = 1;
}

message UpdateJpaResponse {
    bool new_app_created = 1;
    string uni_pat_num = 2;
}

message PatentPubRequest {
    string app_no_ed = 1;
    string doc_db_xml = 2;
}

message PatentPubResponse {
    string app_no_ed = 1;
    bool new_record = 2;
    PatentPub patent_pub = 3;
    bool unable_to_save = 4;
}

